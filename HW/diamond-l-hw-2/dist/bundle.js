/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/audio.js":
/*!**********************!*\
  !*** ./src/audio.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"analyserNode\": () => (/* binding */ analyserNode),\n/* harmony export */   \"audioCtx\": () => (/* binding */ audioCtx),\n/* harmony export */   \"bassNode\": () => (/* binding */ bassNode),\n/* harmony export */   \"loadSoundFile\": () => (/* binding */ loadSoundFile),\n/* harmony export */   \"pauseCurrentSound\": () => (/* binding */ pauseCurrentSound),\n/* harmony export */   \"playCurrentSound\": () => (/* binding */ playCurrentSound),\n/* harmony export */   \"setVolume\": () => (/* binding */ setVolume),\n/* harmony export */   \"setupWebaudio\": () => (/* binding */ setupWebaudio),\n/* harmony export */   \"trebleNode\": () => (/* binding */ trebleNode)\n/* harmony export */ });\n// 1 - our WebAudio context, **we will export and make this public at the bottom of the file**\r\nlet audioCtx;\r\n\r\n// **These are \"private\" properties - these will NOT be visible outside of this module (i.e. file)**\r\n// 2 - WebAudio nodes that are part of our WebAudio audio routing graph\r\nlet element, sourceNode, analyserNode, gainNode, bassNode, trebleNode;\r\n\r\n// 3 - here we are faking an enumeration\r\nconst DEFAULTS = Object.freeze({\r\n    gain : 0.5,\r\n    numSamples : 256\r\n\r\n\r\n});\r\n\r\n// 4 - create a new array of 8-bit integers (0-255)\r\n// this is a typed array to hold the audio frequency data\r\nlet audioData = new Uint8Array(DEFAULTS.numSamples/2);\r\n\r\n\r\n// **Next are \"public\" methods - we are going to export all of these at the bottom of this file**\r\nconst setupWebaudio = (filePath) =>{\r\n// 1 - The || is because WebAudio has not been standardized across browsers yet\r\nconst AudioContext = window.AudioContext || window.webkitAudioContext;\r\naudioCtx = new AudioContext();\r\n\r\n// 2 - this creates an <audio> element\r\nelement = new Audio();\r\n\r\n// 3 - have it point at a sound file\r\nloadSoundFile(filePath);\r\n\r\n// 4 - create an a source node that points at the <audio> element\r\nsourceNode = audioCtx.createMediaElementSource(element);\r\n\r\n// 5 - create an analyser node\r\n// note the UK spelling of \"Analyser\"\r\nanalyserNode = audioCtx.createAnalyser();\r\n/*\r\n// 6\r\nWe will request DEFAULTS.numSamples number of samples or \"bins\" spaced equally \r\nacross the sound spectrum.\r\n\r\nIf DEFAULTS.numSamples (fftSize) is 256, then the first bin is 0 Hz, the second is 172 Hz, \r\nthe third is 344Hz, and so on. Each bin contains a number between 0-255 representing \r\nthe amplitude of that frequency.\r\n*/ \r\n\r\n// fft stands for Fast Fourier Transform\r\nanalyserNode.fftSize = DEFAULTS.numSamples;\r\n\r\n// 7 - create a gain (volume) node\r\ngainNode = audioCtx.createGain();\r\ngainNode.gain.value = DEFAULTS.gain;\r\n\r\n//creating effect nodes\r\nbassNode = audioCtx.createBiquadFilter();\r\nbassNode.type = \"lowshelf\";\r\n\r\ntrebleNode = audioCtx.createBiquadFilter();\r\ntrebleNode.type = \"highshelf\";\r\n\r\n// 8 - connect the nodes - we now have an audio graph\r\nsourceNode.connect(analyserNode);\r\nanalyserNode.connect(gainNode);\r\ngainNode.connect(bassNode);\r\nbassNode.connect(trebleNode);\r\ntrebleNode.connect(audioCtx.destination)\r\n}\r\n\r\n//helper method for loading new sound file\r\nconst loadSoundFile = (filePath) =>{\r\n    element.src = filePath;\r\n}\r\n\r\n//helper method for play button\r\nconst playCurrentSound = () =>{\r\n    element.play();\r\n}\r\n//helper method for pause button\r\nconst pauseCurrentSound = () =>{\r\n    element.pause();\r\n}\r\n\r\n//helper method for volume slider\r\nconst setVolume = (value) =>{\r\n    value = Number(value);// make sure that it's a Number rather than a String\r\n    gainNode.gain.value = value;\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://diamond-l-hw-2/./src/audio.js?");

/***/ }),

/***/ "./src/canvas.js":
/*!***********************!*\
  !*** ./src/canvas.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"draw\": () => (/* binding */ draw),\n/* harmony export */   \"setupCanvas\": () => (/* binding */ setupCanvas)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./src/utils.js\");\n/* harmony import */ var _loader_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loader.js */ \"./src/loader.js\");\n/* harmony import */ var _audio_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./audio.js */ \"./src/audio.js\");\n/*\r\n\tThe purpose of this file is to take in the analyser node and a <canvas> element: \r\n\t  - the module will create a drawing context that points at the <canvas> \r\n\t  - it will store the reference to the analyser node\r\n\t  - in draw(), it will loop through the data in the analyser node\r\n\t  - and then draw something representative on the canvas\r\n\t  - maybe a better name for this file/module would be *visualizer.js* ?\r\n*/\r\n\r\n\r\n\r\n\r\n\r\nlet ctx,canvasWidth,canvasHeight,gradient,analyserNode,audioData;\r\nlet sprites = [];\r\nlet img;\r\nclass hornSprite{\r\n    static type = \"triangle\"; // demoing a static (class) variable here\r\n    constructor(direction, translateX, translateY){\r\n    \r\n    this.counter = 0;\r\n    this.hue = 0\r\n    this.color = `hsl(${this.hue}, 100%, 10%)`\r\n     Object.assign(this, {direction, translateX, translateY});\r\n    }\r\n    \r\n    update(audioData){\r\n        //color changes over time as the song continues\r\n        this.hue += _audio_js__WEBPACK_IMPORTED_MODULE_2__.audioCtx.currentTime/255;\r\n        //resets color\r\n        if(this.hue >= 255)\r\n        {\r\n            this.hue = 0;\r\n        }\r\n        //saturation is controled by audio data\r\n        let saturation = 40 + (audioData * 2);\r\n        //caps saturation\r\n        if(saturation > 100){\r\n            saturation = 100;\r\n        }\r\n\r\n        this.color = `hsl(${this.hue}, ${saturation}%, 50%)`\r\n    }\r\n    \r\n    draw(ctx, playing){\r\n        //stops color change when not playing\r\n        if(playing){\r\n            ctx.save();\r\n           \r\n            \r\n            //this.counter += audioCtx.currentTime\r\n            //let percent = this.counter/255;\r\n            //goes to new origin\r\n            ctx.translate(this.translateX, this.translateY);\r\n            //angles horns\r\n            if(this.direction == \"right\"){\r\n                ctx.rotate(-Math.PI/8);\r\n            }\r\n            else if(this.direction == \"left\"){\r\n                ctx.rotate(Math.PI/8);\r\n            }\r\n            \r\n            //draws the horn\r\n            ctx.globalAlpha = 0.5;\r\n            ctx.fillStyle = this.color;\r\n            \r\n            //ctx.lineWidth=2;\r\n            ctx.beginPath();\r\n\r\n            ctx.moveTo(30,110);\r\n            ctx.lineTo(80,40);\r\n            ctx.lineTo(130,110);\r\n            \r\n            ctx.closePath();\r\n            \r\n            ctx.fill();\r\n            \r\n            ctx.restore();\r\n        }\r\n       \r\n    }\r\n  }\r\n\r\n  //loads in the image to be drawn to the screen\r\n  const loadImage = (url) =>{\r\n    img = new Image;\r\n    img.onerror = _=>{\r\n        console.log(`Image Error`);\r\n      };\r\n  \r\n      \r\n      img.src = url;\r\n\r\n  }\r\n\r\nconst setupCanvas = (canvasElement,analyserNodeRef) =>{\r\n\t// create drawing context\r\n\tctx = canvasElement.getContext(\"2d\");\r\n\tcanvasWidth = canvasElement.width;\r\n\tcanvasHeight = canvasElement.height;\r\n\t// create a gradient that runs top to bottom\r\n\tgradient = _utils_js__WEBPACK_IMPORTED_MODULE_0__.getLinearGradient(ctx,0,0,0,canvasHeight,[{percent:0,color:\"blue\"},{percent:.25,color:\"green\"},{percent:.5,color:\"yellow\"},{percent:.75,color:\"red\"},{percent:1,color:\"magenta\"}]);\r\n\t// keep a reference to the analyser node\r\n\tanalyserNode = analyserNodeRef;\r\n\t// this is the array where the analyser data will be stored\r\n\taudioData = new Uint8Array(analyserNode.fftSize/2);\r\n    sprites.push(new hornSprite(\"right\", 0, 10));\r\n    //sprites.push(new TriangleSprite(400, 110, 450, 40, 500, 110));\r\n    sprites.push(new hornSprite(\"left\", 650, -55));\r\n    loadImage(_loader_js__WEBPACK_IMPORTED_MODULE_1__.imageURL);\r\n}\r\n\r\nconst draw = (params={}, dataType) =>{\r\n  //gets the audio data based on whether the user has selected frequency or waveform\r\n    if(dataType == \"frequency\"){\r\n         analyserNode.getByteFrequencyData(audioData);\r\n    }\r\n    else{ \r\n        analyserNode.getByteTimeDomainData(audioData);\r\n    }\r\n\t\r\n\t\r\n\r\n\r\n\t// 2 - draw background\r\n\tctx.save();\r\n    ctx.drawImage(img, 0, 0, canvasWidth, canvasHeight);\r\n    ctx.restore()\r\n\t\t\r\n   \r\n        //sprite update\r\n        if(params.horns){\r\n            for(let i = 0; i < audioData.length; i++){\r\n                sprites[0].update(audioData[i], audioData[i]);\r\n                sprites[0].draw(ctx, params.playing);\r\n                sprites[1].update(audioData[i], audioData[i]);\r\n                sprites[1].draw(ctx, params.playing);\r\n            \r\n            \r\n            }\r\n        }\r\n        \r\n       \r\n        //eye background that grows and shrinks based on audio data\r\n        if(params.backEyes){\r\n            for(let i = 0; i < audioData.length; i++){\r\n            ctx.save()\r\n            ctx.beginPath();\r\n            ctx.fillStyle = 'white';\r\n            ctx.moveTo(300, 230);\r\n            ctx.lineTo(325, 190);\r\n            ctx.lineTo(300, 120);\r\n            ctx.lineTo(315 - audioData[i] / 2, 190 - audioData[i] / 2);\r\n            ctx.closePath();\r\n            ctx.fill();\r\n\r\n            ctx.beginPath();\r\n            ctx.moveTo(500, 230);\r\n            ctx.lineTo(475, 190);\r\n            ctx.lineTo(500, 120);\r\n            ctx.lineTo(485 + audioData[i] / 2, 190 - audioData[i] / 2);\r\n            ctx.closePath();\r\n            ctx.fill();\r\n            ctx.restore()\r\n            }\r\n        }\r\n\r\n        //arc that varies based on audio data to look like eyes opening\r\n        if(params.frontEyes){\r\n            for(let i = 0; i < audioData.length; i++){\r\n                ctx.save();\r\n                    ctx.fillStyle = `red`\r\n                    ctx.beginPath();\r\n                    ctx.moveTo(225, 150);             \t// P0\r\n                    ctx.arcTo(275, 150 - audioData[i] / 8, 326, 150, 120); \t// P1, P2 and the radius\r\n                    ctx.lineTo(325, 150);               // top line: line segment between P0 & P2     \r\n                    ctx.closePath();          \r\n                    ctx.fill(); \r\n                    \r\n                   \r\n                    ctx.beginPath();\r\n                    ctx.moveTo(475, 150);             \t// P0\r\n                    ctx.arcTo(525, 150 - audioData[i] / 8, 575, 150, 120); \t// P1, P2 and the radius\r\n                    ctx.lineTo(575, 150);               // top line: line segment between P0 & P2     \r\n                    ctx.closePath();          \r\n                    ctx.fill(); \r\n                    ctx.restore();\r\n              \r\n                }\r\n        }\r\n        \r\n       \r\n      // changed bars from the start code to follow a more parabolic shape to look like many teeth moving up and down\r\n\tif(params.showBars){\r\n        let barSpacing = 4;\r\n        let margin = 5;\r\n        let screenWidthForBars = canvasWidth - (audioData.length * barSpacing) - margin * 2;\r\n        let barWidth = screenWidthForBars / audioData.length;\r\n        let maxBarHeight = 10;\r\n        let topSpacing = 100;\r\n        \r\n        ctx.save();\r\n        ctx.fillStyle = `rgba(255,255,255,0.5)`;\r\n        ctx.strokeStyle = `rgba(0,0,0,0.5)`;\r\n        //loop through data and draw\r\n        for(let i = 0; i < audioData.length; i++){\r\n            let temp =  -1 * (i - (audioData.length/2)) * (i - (audioData.length/2));\r\n            ctx.fillRect(margin + i * (barWidth * barSpacing), canvasHeight, barWidth, -1 * (maxBarHeight - temp / 50 + audioData[i]/ 5) - i);\r\n            ctx.strokeRect(margin + i * (barWidth * barSpacing), canvasHeight, barWidth, -1 * (maxBarHeight - temp / 50 + audioData[i]/ 5) - i);\r\n        }\r\n        ctx.restore();\r\n    }\r\n        /* unused code from starter\r\n\t// 3 - draw gradient\r\n    if(params.showGradient){\r\n        ctx.save()\r\n        ctx.fillStyle = gradient;\r\n        ctx.globalAlpha = 0.3;\r\n        ctx.fillRect(0,0,canvasWidth,canvasHeight);\r\n        ctx.restore();\r\n    }\r\n\t\r\n\t\r\n\t// 5 - draw circles\r\n    if(params.showCircles){\r\n        let maxRadius = canvasHeight / 4;\r\n        ctx.save();\r\n        ctx.globalAlpha = 0.5;\r\n        for(let i =0; i < audioData.length; i++){\r\n            //red-ish circles\r\n            let percent= audioData[i] / 255;\r\n\r\n            let circleRadius = percent * maxRadius;\r\n\r\n            ctx.beginPath();\r\n            ctx.fillStyle = utils.makeColor(255, 111, 111, 0.34 - percent/3.0);\r\n            ctx.arc(canvasWidth/2, canvasHeight/2, circleRadius, 0, Math.PI * 2, false);\r\n            ctx.fill();\r\n            ctx.closePath();\r\n\r\n            //bigger more transparent blueish circles\r\n            ctx.beginPath();\r\n            ctx.fillStyle = utils.makeColor(0,0,255, .10 - percent/10.0 );\r\n            ctx.arc(canvasWidth/2, canvasHeight/2, circleRadius * 1.5, 0, Math.PI * 2, false);\r\n            ctx.fill()\r\n            ctx.closePath();\r\n\r\n            \r\n            //smaller yellow circles\r\n            ctx.save();\r\n            ctx.beginPath();\r\n            ctx.fillStyle = utils.makeColor(200, 200, 0, .5 - percent/5.0);\r\n            ctx.arc(canvasWidth/2, canvasHeight/2, circleRadius * 0.5, 0, Math.PI * 2, false);\r\n            ctx.fill();\r\n            ctx.closePath()\r\n            ctx.restore();\r\n\r\n        }\r\n\r\n        ctx.restore()\r\n    }\r\n*/\r\n    \r\n    \r\n    // 6 - bitmap manipulation\r\n\t// TODO: right now. we are looping though every pixel of the canvas (320,000 of them!), \r\n\t// regardless of whether or not we are applying a pixel effect\r\n\t// At some point, refactor this code so that we are looping though the image data only if\r\n\t// it is necessary\r\n\r\n\t// A) grab all of the pixels on the canvas and put them in the `data` array\r\n\t// `imageData.data` is a `Uint8ClampedArray()` typed array that has 1.28 million elements!\r\n\t// the variable `data` below is a reference to that array \r\n\tlet imageData = ctx.getImageData(0,0,canvasWidth, canvasHeight);\r\n    let data = imageData.data;\r\n    let length = data.length;\r\n    let width = imageData.width;\r\n\r\n\r\n    \r\n\t// B) Iterate through each pixel, stepping 4 elements at a time (which is the RGBA for 1 pixel)\r\n    for(let i = 0; i < length; i+=4){\r\n\t\t// C) randomly change every 20th pixel to red\r\n        if(params.showNoise && Math.random() < .05){\r\n\r\n        \r\n\t\t\t// data[i] is the red channel\r\n\t\t\t// data[i+1] is the green channel\r\n\t\t\t// data[i+2] is the blue channel\r\n\t\t\t// data[i+3] is the alpha channel\r\n\t\t\tdata[i] = data[i + 1]  = data[i+2] = 0;// zero out the red and green and blue channels\r\n\t\t\tdata[i + 1] = 255;// make the green channel 100% \r\n\t\t} // end if\r\n        //invert\r\n    if(params.showInvert){\r\n        let red = data[i], green = data[i + 1], blue = data[i + 2];\r\n        data[i] = 255 - red;\r\n        data [i + 1] = 255 - green;\r\n        data[i + 2] = 255 - blue;\r\n         \r\n    }\r\n\t} // end for\r\n\r\n    if(params.showEmboss){\r\n        for(let i = 0; i < length; i++){\r\n            if(i%4 == 3) continue; // skip alpha channel\r\n\r\n            data[i] = 127 + 2 * data[i] - data[i +4] - data[i + width * 4]\r\n        }\r\n    }\r\n\t\r\n\t// D) copy image data back to canvas\r\n    ctx.putImageData(imageData,0,0);\r\n\r\n    \r\n}\r\n\r\n\n\n//# sourceURL=webpack://diamond-l-hw-2/./src/canvas.js?");

/***/ }),

/***/ "./src/loader.js":
/*!***********************!*\
  !*** ./src/loader.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"imageURL\": () => (/* binding */ imageURL)\n/* harmony export */ });\n/* harmony import */ var _main_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./main.js */ \"./src/main.js\");\n\r\n\r\nlet imageURL;\r\n\r\nwindow.onload = ()=>{\r\n\tconsole.log(\"window.onload called\");\r\n\t// 1 - do preload here - load fonts, images, additional sounds, etc...\r\n\tloadFromJSON();\r\n\r\n\t\r\n\t\r\n}\r\n\r\n//pulls in data from json file, parses it, and outputs it to the DOM\r\nconst loadFromJSON = () =>{\r\n\tconst url = \"data/av-data.json\";\r\n\tconst xhr = new XMLHttpRequest();\r\n\r\n\txhr.onload = (e) =>{\r\n\t\tconsole.log(`In onload - HTTP status code = ${e.target.status}`);\r\n\t\tconst string = e.target.responseText;\r\n\t\tconsole.log(e.target);\r\n\r\n\t\tconst json = JSON.parse(string);\r\n\r\n\t\tdocument.querySelector(\"title\").innerHTML = json.title;\r\n\r\n\t\t//fills the DOM track select\r\n\t\tconst trackSelect = document.querySelector(\"#track-select\");\r\n\t\tlet innerHTML;\r\n\t\tfor(let i = 0; i < json.audioFiles.length; i++){\r\n\t\t\tinnerHTML += `<option value=\"${json.audioFiles[i].file}\">${json.audioFiles[i].trackName}</option>`\r\n\t\t}\r\n\r\n\t\ttrackSelect.innerHTML = innerHTML;\r\n\t\t\r\n\t\t//stores image URL to be exported\r\n\t\timageURL = json.imageURL\r\n\r\n\t\t//once data has been loaded calls init and sends the audio files array for use in datGUI set up\r\n\t\t_main_js__WEBPACK_IMPORTED_MODULE_0__.init(json.audioFiles);\r\n\t};\r\n\txhr.onerror = e => console.log(`In onerror - HTTP status code = ${e.target.status}`);\r\n\txhr.open(\"GET\", url);\r\n\txhr.send();\r\n}\r\n\r\n\n\n//# sourceURL=webpack://diamond-l-hw-2/./src/loader.js?");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"init\": () => (/* binding */ init)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./src/utils.js\");\n/* harmony import */ var _audio_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./audio.js */ \"./src/audio.js\");\n/* harmony import */ var _canvas_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./canvas.js */ \"./src/canvas.js\");\n/*\r\n\tmain.js is primarily responsible for hooking up the UI to the rest of the application \r\n\tand setting up the main event loop\r\n*/\r\n\r\n// We will write the functions in this file in the traditional ES5 way\r\n// In this instance, we feel the code is more readable if written this way\r\n// If you want to re-write these as ES6 arrow functions, to be consistent with the other files, go ahead!\r\n\r\n\r\n\r\n\r\n\r\nconst drawParams = {\r\n    horns: true,\r\n backEyes : true,\r\n showBars : true,\r\n frontEyes : true,\r\n showNoise : true,\r\n showInvert : true,\r\n showEmboss : true,\r\n playing : false\r\n\r\n}\r\n\r\nlet visualizationType = \"frequency\"\r\n\r\n\r\nlet volumeSlider;\r\nlet volumeLabel;\r\nlet bassSlider;\r\nlet bassLabel;\r\n\r\n//object holding data and methods for datGUI\r\nconst controllerObject = {\r\n\r\n_track : \"media/Judgement - Kensuke Ushio.mp3\",\r\n_visualizationType : \"frequency\",\r\n_volume : 1,\r\n_lowPass : 0.25,\r\n_highPass: 0.25,\r\n_showBackEyes : true,\r\n_showHorns : true,\r\n_showFrontEyes : true,\r\n_showMouth : true,\r\n_showNoise : true,\r\n_showInvert : true,\r\n_showEmboss : true,\r\n\r\n//checkbox get and set -ers\r\nget showBackEyes(){\r\n    return this._showBackEyes\r\n},\r\n\r\nset showBackEyes(value){\r\n    this._showBackEyes = value;\r\n    drawParams.backEyes = this._showBackEyes\r\n},\r\n\r\nget showFrontEyes(){\r\n    return this._showFrontEyes\r\n},\r\n\r\nset showFrontEyes(value){\r\n    this._showFrontEyes = value;\r\n    drawParams.frontEyes = this._showFrontEyes\r\n},\r\n\r\n\r\nget showMouth(){\r\n    return this._showMouth;\r\n},\r\n\r\nset showMouth(value){\r\n    this._showMouth = value;\r\n    \r\n    drawParams.showBars = this._showMouth\r\n},\r\n\r\nget showHorns(){\r\n    return this._showHorns;\r\n},\r\n\r\nset showHorns(value){\r\n    this._showHorns = value;\r\n    drawParams.horns = this._showHorns\r\n},\r\n\r\nget showNoise(){\r\n    return this._showNoise;\r\n},\r\n\r\nset showNoise(value){\r\n    this._showNoise = value;\r\n    drawParams.showNoise = this._showNoise\r\n},\r\n\r\nget showInvert(){\r\n    return this._showInvert;\r\n},\r\n\r\nset showInvert(value){\r\n    this._showInvert = value;\r\n    //invertCheckBox.checked = value;\r\n    drawParams.showInvert = this._showInvert;\r\n},\r\n\r\nget showEmboss(){\r\n    return this._showEmboss;\r\n},\r\n\r\nset showEmboss(value){\r\n    this._showEmboss = value;\r\n    drawParams.showEmboss = this._showEmboss;\r\n},\r\n\r\n//slider controlers\r\nget volume(){\r\n    return this._volume;\r\n},\r\n\r\nset volume(value){\r\n    this._volume = value;\r\n    _audio_js__WEBPACK_IMPORTED_MODULE_1__.setVolume(this._volume);\r\n},\r\n\r\nget lowPass(){\r\n    return this._lowPass;\r\n},\r\n\r\nset lowPass(value){\r\n    this._lowPass = value;\r\n    _audio_js__WEBPACK_IMPORTED_MODULE_1__.bassNode.gain.setValueAtTime(this._lowPass/2 * 100, _audio_js__WEBPACK_IMPORTED_MODULE_1__.audioCtx.currentTime);\r\n    //bassSlider.value = value;\r\n    //bassLabel.innerHTML = Math.round((e.target.value/2 * 400));\r\n},\r\n\r\nget highPass(){\r\n    return this._highPass;\r\n},\r\n\r\nset highPass(value){\r\n    this._highPass = value;\r\n    _audio_js__WEBPACK_IMPORTED_MODULE_1__.trebleNode.gain.setValueAtTime(this._highPass/2 * 100, _audio_js__WEBPACK_IMPORTED_MODULE_1__.audioCtx.currentTime);\r\n},\r\n\r\n//drop down menus\r\nget track(){\r\n    return this._track;\r\n\r\n},\r\n\r\nset track(value){\r\n    this._track = value;\r\n    _audio_js__WEBPACK_IMPORTED_MODULE_1__.loadSoundFile(this._track);\r\n    \r\n    if(drawParams.playing){\r\n        _audio_js__WEBPACK_IMPORTED_MODULE_1__.playCurrentSound();\r\n        \r\n        drawParams.playing = true;\r\n    }\r\n},\r\n\r\nget visualizationType(){\r\n    return this._visualizationType;\r\n},\r\n\r\nset visualizationType(value){\r\n    this._visualizationType = value;\r\n    visualizationType = this._visualizationType;\r\n},\r\n\r\n\r\n//buttons\r\nplay(){\r\n   playAudio()\r\n},\r\n\r\npause(){\r\n    pauseAudio();\r\n},\r\n\r\nfullscreen(){\r\n    _utils_js__WEBPACK_IMPORTED_MODULE_0__.goFullscreen(document.documentElement);\r\n}\r\n\r\n\r\n}\r\n  \r\n\r\n\r\n\r\n// 1 - here we are faking an enumeration\r\nconst DEFAULTS = Object.freeze({\r\n\tsound1  :  \"media/Judgement - Kensuke Ushio.mp3\"\r\n});\r\n\r\nconst init = (audioFiles) =>{\r\n    _audio_js__WEBPACK_IMPORTED_MODULE_1__.setupWebaudio(DEFAULTS.sound1);\r\n\tconsole.log(\"init called\");\r\n\tconsole.log(`Testing utils.getRandomColor() import: ${_utils_js__WEBPACK_IMPORTED_MODULE_0__.getRandomColor()}`);\r\n\tlet canvasElement = document.querySelector(\"canvas\"); // hookup <canvas> element\r\n    _audio_js__WEBPACK_IMPORTED_MODULE_1__.loadSoundFile(DEFAULTS.sound1);\r\n\tsetupUI(canvasElement, audioFiles);\r\n    _canvas_js__WEBPACK_IMPORTED_MODULE_2__.setupCanvas(canvasElement,_audio_js__WEBPACK_IMPORTED_MODULE_1__.analyserNode);\r\n    loop();\r\n}\r\n\r\nconst setupUI = (canvasElement, audioFiles) =>{\r\n\r\n    //initializing dat GUI\r\n    const gui = new dat.GUI({ width: 400 });\r\n\tgui.close();\r\n\r\n    //buttons\r\n    gui.add(controllerObject, 'play').name(\"Play\");\r\n    gui.add(controllerObject, 'pause').name(\"Pause\");\r\n    gui.add(controllerObject, 'fullscreen').name(\"Fullscreen\");\r\n\r\n    \r\n    let trackList = {}\r\n\r\n    //compiles the tracklist loaded in from the json file into an object literal which is passed into the dropdown menu\r\n    for(let track of audioFiles){\r\n        let newTrack = track.trackName\r\n        trackList[newTrack] = track.file\r\n    }\r\n\r\n    //drop down menus\r\n    gui.add(controllerObject, 'track', trackList ).name('Track');\r\n    gui.add(controllerObject, 'visualizationType', { Frequency: \"frequency\", WaveLength: \"waveLength\"} ).name('Visualization Type');\r\n\r\n    //sliders\r\n    gui.add(controllerObject, 'volume').min(0).max(2).step(0.1).name('Volume');\r\n    gui.add(controllerObject, 'lowPass').min(0).max(1).step(\"0.01\").name('Low Pass Filter');\r\n    gui.add(controllerObject, 'highPass').min(0).max(1).step(\"0.01\").name('High Pass Filter');\r\n\r\n    //check boxes\r\n    gui.add(controllerObject, 'showBackEyes').name(\"Show Back Eyes\");\r\n    gui.add(controllerObject, 'showFrontEyes').name(\"Show Front Eyes\");\r\n    gui.add(controllerObject, 'showMouth').name(\"Show Mouth\");\r\n    gui.add(controllerObject, 'showHorns').name(\"Show Horns\");\r\n    gui.add(controllerObject, 'showNoise').name(\"Show Noise\");\r\n    gui.add(controllerObject, 'showInvert').name(\"Show Invert\");\r\n    gui.add(controllerObject, 'showEmboss').name(\"Show Emboss\");\r\n\r\n\r\n\r\n\r\n//initializing DOM controls\r\n  // A - hookup fullscreen button\r\n  const fsButton = document.querySelector(\"#fs-button\");\r\n  const playButton = document.querySelector(\"#play-button\");\r\n\r\n  // add .onclick event to button\r\n  fsButton.onclick = e => {\r\n    console.log(\"init called\");\r\n    _utils_js__WEBPACK_IMPORTED_MODULE_0__.goFullscreen(canvasElement);\r\n  };\r\n\r\n  playButton.onclick = e =>{\r\n    console.log(`audioCtx.state before = ${_audio_js__WEBPACK_IMPORTED_MODULE_1__.audioCtx.state}`);\r\n\r\n    //check if context is in suspended state\r\n    if(_audio_js__WEBPACK_IMPORTED_MODULE_1__.audioCtx.state == \"suspended\"){\r\n        _audio_js__WEBPACK_IMPORTED_MODULE_1__.audioCtx.resume();\r\n        drawParams.playing = true;\r\n    }\r\n    console.log(`audioCtx.state after = ${_audio_js__WEBPACK_IMPORTED_MODULE_1__.audioCtx.state}`);\r\n    //if track is currently paused play it\r\n    if(e.target.dataset.playing == \"no\"){\r\n        _audio_js__WEBPACK_IMPORTED_MODULE_1__.playCurrentSound();\r\n        e.target.dataset.playing = \"yes\";\r\n        drawParams.playing = true;\r\n       \r\n    }\r\n    //if track is currently playing pause it\r\n    else{\r\n        _audio_js__WEBPACK_IMPORTED_MODULE_1__.pauseCurrentSound();\r\n        e.target.dataset.playing = \"no\";\r\n        drawParams.playing = false;\r\n        \r\n    }\r\n  }\r\n\r\n  //hookup volume slider and label\r\n  volumeSlider = document.querySelector(\"#volume-slider\");\r\n  volumeLabel = document.querySelector(\"#volume-label\");\r\n\r\n  //add oninput event\r\n\tvolumeSlider.oninput = e =>{\r\n        //set volume\r\n        _audio_js__WEBPACK_IMPORTED_MODULE_1__.setVolume(e.target.value);\r\n        //update value of the label to match volume\r\n        volumeLabel.innerHTML = Math.round((e.target.value/2 * 100));\r\n\r\n    }\r\n    //set value of label to match slider on set up\r\n    volumeSlider.dispatchEvent(new Event(\"input\"));\r\n\r\n    //hookup volume slider and label\r\n    bassSlider = document.querySelector(\"#bass-slider\");\r\n    bassLabel = document.querySelector(\"#bass-label\");\r\n\r\n  //add oninput event\r\n\tbassSlider.oninput = e =>{\r\n        //set volume\r\n        _audio_js__WEBPACK_IMPORTED_MODULE_1__.bassNode.gain.setValueAtTime(e.target.value/2 * 100, _audio_js__WEBPACK_IMPORTED_MODULE_1__.audioCtx.currentTime);\r\n        //update value of the label to match volume\r\n        bassLabel.innerHTML = Math.round((e.target.value/2 * 400));\r\n\r\n    }\r\n    //set value of label to match slider on set up\r\n    bassSlider.dispatchEvent(new Event(\"input\"));\r\n\r\n      //hookup volume slider and label\r\n  let trebleSlider = document.querySelector(\"#treble-slider\");\r\n  let trebleLabel = document.querySelector(\"#treble-label\");\r\n\r\n  //add oninput event\r\n  trebleSlider.oninput = e =>{\r\n        //set volume\r\n        _audio_js__WEBPACK_IMPORTED_MODULE_1__.trebleNode.gain.setValueAtTime(e.target.value/2 * 100, _audio_js__WEBPACK_IMPORTED_MODULE_1__.audioCtx.currentTime);\r\n        //update value of the label to match volume\r\n        trebleLabel.innerHTML = Math.round((e.target.value/2 * 400));\r\n\r\n    }\r\n    //set value of label to match slider on set up\r\n    trebleSlider.dispatchEvent(new Event(\"input\"));\r\n\r\n    //hookup track selector\r\n    let trackSelect = document.querySelector(\"#track-select\");\r\n\r\n    trackSelect.onchange = e =>{\r\n        _audio_js__WEBPACK_IMPORTED_MODULE_1__.loadSoundFile(e.target.value);\r\n        //pause the current track if it is playing\r\n        if(drawParams.playing == true){\r\n            _audio_js__WEBPACK_IMPORTED_MODULE_1__.playCurrentSound();\r\n            drawParams.playing = true;\r\n        }\r\n    }\r\n    \r\n    let backEyesCheckBox = document.querySelector(\"#back-eyes-check\");\r\n    backEyesCheckBox.onclick = e =>{\r\n        \r\n        drawParams.backEyes = e.target.checked;\r\n       \r\n    }\r\n    backEyesCheckBox.checked = true;\r\n    backEyesCheckBox.dispatchEvent(new Event(\"click\"));\r\n   \r\n    let frontEyesCheckBox = document.querySelector(\"#front-eyes-check\");\r\n    frontEyesCheckBox.onclick = e =>{\r\n        \r\n        drawParams.frontEyes = e.target.checked;\r\n       console.log(drawParams.frontEyes);\r\n    }\r\n    frontEyesCheckBox.checked = true;\r\n    frontEyesCheckBox.dispatchEvent(new Event(\"click\"));\r\n\r\n    let hornsCheckBox = document.querySelector(\"#horns-check\");\r\n    hornsCheckBox.onclick = e =>{\r\n        \r\n        drawParams.horns = e.target.checked;\r\n       console.log(drawParams.horns);\r\n    }\r\n    hornsCheckBox.checked = true;\r\n   hornsCheckBox.dispatchEvent(new Event(\"click\"));\r\n\r\n   let barsCheckBox = document.querySelector(\"#bars-check\");\r\n    barsCheckBox.onclick = e =>{\r\n        \r\n        drawParams.showBars = e.target.checked;\r\n       \r\n    }\r\n    barsCheckBox.checked = true;\r\n   barsCheckBox.dispatchEvent(new Event(\"click\"));\r\n\r\n   \r\n\r\n    let noiseCheckBox = document.querySelector(\"#noise-check\");\r\n    noiseCheckBox.onclick = e =>{\r\n        console.log(e.target.checked)\r\n        drawParams.showNoise = e.target.checked;\r\n       \r\n    }\r\n    noiseCheckBox.checked = true;\r\n    noiseCheckBox.dispatchEvent(new Event(\"click\"));\r\n\r\n    let invertCheckBox = document.querySelector(\"#invert-check\");\r\n    invertCheckBox.onclick = e =>{\r\n        console.log(e.target.checked)\r\n        drawParams.showInvert = e.target.checked;\r\n       \r\n    }\r\n    invertCheckBox.checked = true;\r\n    invertCheckBox.dispatchEvent(new Event(\"click\"));\r\n\r\n    let embossCheckBox = document.querySelector(\"#emboss-check\");\r\n   embossCheckBox.onclick = e =>{\r\n        \r\n        drawParams.showEmboss = e.target.checked;\r\n        gui\r\n        controllerObject.showEmboss = e.target.checked;\r\n       \r\n    }\r\n    embossCheckBox.checked = true;\r\n    embossCheckBox.dispatchEvent(new Event(\"click\"));\r\n\r\n    let visualizationTypeSelector = document.querySelector(\"#visualization-type\");\r\n    visualizationTypeSelector.onchange = e =>{\r\n        visualizationType = e.target.value;\r\n    }\r\n    \r\n    \r\n} // end setupUI\r\n\r\nconst loop = () =>{\r\n    //called 60 times per second draws visualizer based on params\r\n        setTimeout(loop, 1/60);\r\n        _canvas_js__WEBPACK_IMPORTED_MODULE_2__.draw(drawParams, visualizationType);\r\n        \r\n    }\r\n\r\n\r\n\r\n//helper methods for play and pause buttons\r\nconst playAudio = () =>{\r\n    //if track is currently paused play it\r\n    if(drawParams.playing == false){\r\n        _audio_js__WEBPACK_IMPORTED_MODULE_1__.playCurrentSound();\r\n        //e.target.dataset.playing = \"yes\";\r\n        drawParams.playing = true;\r\n       \r\n    }\r\n     //check if context is in suspended state\r\n     if(_audio_js__WEBPACK_IMPORTED_MODULE_1__.audioCtx.state == \"suspended\"){\r\n        _audio_js__WEBPACK_IMPORTED_MODULE_1__.audioCtx.resume();\r\n        drawParams.playing = true;\r\n    }\r\n    console.log(`audioCtx.state after = ${_audio_js__WEBPACK_IMPORTED_MODULE_1__.audioCtx.state}`);\r\n    \r\n}\r\n\r\nconst pauseAudio = () =>{\r\n    if(drawParams.playing == true){\r\n        _audio_js__WEBPACK_IMPORTED_MODULE_1__.pauseCurrentSound();\r\n        //e.target.dataset.playing = \"no\";\r\n        drawParams.playing = false;\r\n    }\r\n}\n\n//# sourceURL=webpack://diamond-l-hw-2/./src/main.js?");

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\
  !*** ./src/utils.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getLinearGradient\": () => (/* binding */ getLinearGradient),\n/* harmony export */   \"getRandomColor\": () => (/* binding */ getRandomColor),\n/* harmony export */   \"goFullscreen\": () => (/* binding */ goFullscreen),\n/* harmony export */   \"makeColor\": () => (/* binding */ makeColor)\n/* harmony export */ });\nconst makeColor = (red, green, blue, alpha = 1) => {\r\n    return `rgba(${red},${green},${blue},${alpha})`;\r\n  };\r\n  \r\n  const getRandom = (min, max) => {\r\n    return Math.random() * (max - min) + min;\r\n  };\r\n  \r\n  const getRandomColor = () => {\r\n    const floor = 35; // so that colors are not too bright or too dark \r\n    const getByte = () => getRandom(floor,255-floor);\r\n    return `rgba(${getByte()},${getByte()},${getByte()},1)`;\r\n  };\r\n  \r\n  const getLinearGradient = (ctx,startX,startY,endX,endY,colorStops) => {\r\n    let lg = ctx.createLinearGradient(startX,startY,endX,endY);\r\n    for(let stop of colorStops){\r\n      lg.addColorStop(stop.percent,stop.color);\r\n    }\r\n    return lg;\r\n  };\r\n  \r\n  // https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API\r\n  const goFullscreen = (element) => {\r\n    if (element.requestFullscreen) {\r\n      element.requestFullscreen();\r\n    } else if (element.mozRequestFullscreen) {\r\n      element.mozRequestFullscreen();\r\n    } else if (element.mozRequestFullScreen) { // camel-cased 'S' was changed to 's' in spec\r\n      element.mozRequestFullScreen();\r\n    } else if (element.webkitRequestFullscreen) {\r\n      element.webkitRequestFullscreen();\r\n    }\r\n    // .. and do nothing if the method is not supported\r\n  };\r\n  \r\n  \n\n//# sourceURL=webpack://diamond-l-hw-2/./src/utils.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.js");
/******/ 	
/******/ })()
;